{"version":3,"sources":["../../src/crypto/encrypt.ts","../../src/crypto/decrypt.ts"],"names":["crypto","checksum"],"mappings":"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","file":"index.js","sourcesContent":["import crypto from 'crypto';\nimport type { HybridEncryptedPayload, EncryptedPIIPayload } from './types';\n\n/**\n * Encrypt data using hybrid encryption (AES-256-GCM + RSA-OAEP)\n *\n * @param data - Data to encrypt (string or Buffer)\n * @param publicKeyPem - RSA public key in PEM format\n * @returns HybridEncryptedPayload with base64-encoded components\n */\nexport function hybridEncrypt(\n  data: string | Buffer,\n  publicKeyPem: string\n): HybridEncryptedPayload {\n  const dataBuffer =\n    typeof data === 'string' ? Buffer.from(data, 'utf-8') : data;\n\n  // Generate AES-256 key and 12-byte IV\n  const aesKey = crypto.randomBytes(32);\n  const iv = crypto.randomBytes(12);\n\n  // Encrypt with AES-256-GCM\n  const cipher = crypto.createCipheriv('aes-256-gcm', aesKey, iv);\n  const encryptedData = Buffer.concat([\n    cipher.update(dataBuffer),\n    cipher.final(),\n  ]);\n  const authTag = cipher.getAuthTag();\n\n  // Encrypt AES key with RSA-OAEP\n  const encryptedKey = crypto.publicEncrypt(\n    {\n      key: publicKeyPem,\n      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n      oaepHash: 'sha256',\n    },\n    aesKey\n  );\n\n  return {\n    encryptedData: encryptedData.toString('base64'),\n    encryptedKey: encryptedKey.toString('base64'),\n    iv: iv.toString('base64'),\n    authTag: authTag.toString('base64'),\n  };\n}\n\n/**\n * Calculate SHA-256 checksum of data\n *\n * @param data - Data to hash\n * @returns Hex-encoded SHA-256 hash\n */\nexport function checksum(data: string | Buffer): string {\n  const buffer = typeof data === 'string' ? Buffer.from(data) : data;\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}\n\n/**\n * Create encrypted PII payload for a single lender\n *\n * @param lenderId - The lender's ID\n * @param lenderPublicKey - The lender's RSA public key in PEM format\n * @param piiData - The PII data to encrypt\n * @returns EncryptedPIIPayload ready for API submission\n *\n * @example\n * ```typescript\n * import { encryptPII } from '@portola/passage-neobank/crypto';\n *\n * const lenders = await passage.lenders.list({ productType: 'personal', stateCode: 'CA' });\n *\n * const encryptedPayloads = lenders.map(lender =>\n *   encryptPII(lender.lenderId, lender.publicKey, {\n *     firstName: 'John',\n *     lastName: 'Doe',\n *     ssn: '123-45-6789',\n *     dateOfBirth: '1990-01-15',\n *     address: {\n *       street: '123 Main St',\n *       city: 'San Francisco',\n *       state: 'CA',\n *       zip: '94102',\n *     },\n *   })\n * );\n * ```\n */\nexport function encryptPII(\n  lenderId: string,\n  lenderPublicKey: string,\n  piiData: Record<string, unknown>\n): EncryptedPIIPayload {\n  const payload = hybridEncrypt(JSON.stringify(piiData), lenderPublicKey);\n\n  return {\n    lenderId,\n    // Note: encryptedData is JSON-stringified here because EncryptedPIIPayload.encryptedData\n    // is typed as string (for API transport). When parsed, it yields a HybridEncryptedPayload.\n    // This double-serialization is intentional to match the API contract.\n    encryptedData: JSON.stringify(payload),\n  };\n}\n\n/**\n * Encrypt PII for multiple lenders at once\n *\n * Convenience function to encrypt the same PII data for multiple lenders.\n *\n * @param lenders - Array of lender info with IDs and public keys\n * @param piiData - The PII data to encrypt\n * @returns Array of EncryptedPIIPayload, one per lender\n *\n * @example\n * ```typescript\n * import { encryptPIIForLenders } from '@portola/passage-neobank/crypto';\n *\n * const lenders = await passage.lenders.list({ productType: 'personal', stateCode: 'CA' });\n *\n * const encryptedPayloads = encryptPIIForLenders(\n *   lenders.map(l => ({ lenderId: l.lenderId, publicKey: l.publicKey })),\n *   borrowerPII\n * );\n *\n * await passage.applications.create({\n *   productType: 'personal',\n *   encryptedPayloads,\n * });\n * ```\n */\nexport function encryptPIIForLenders(\n  lenders: Array<{ lenderId: string; publicKey: string }>,\n  piiData: Record<string, unknown>\n): EncryptedPIIPayload[] {\n  return lenders.map((lender) =>\n    encryptPII(lender.lenderId, lender.publicKey, piiData)\n  );\n}\n\n/**\n * Encrypt a document for SDX upload\n *\n * Returns a binary payload in the format: [4-byte length][metadata JSON][encrypted data]\n *\n * @param document - The document buffer to encrypt\n * @param publicKey - RSA public key in PEM format\n * @returns Buffer ready for SDX upload\n *\n * @example\n * ```typescript\n * import { encryptDocumentForSDX } from '@portola/passage-neobank/crypto';\n * import fs from 'fs';\n *\n * const document = fs.readFileSync('./drivers_license.pdf');\n * const encrypted = encryptDocumentForSDX(document, lender.publicKey);\n *\n * const result = await passage.sdx.upload({\n *   token: uploadToken,\n *   encryptedDocument: encrypted,\n *   filename: 'drivers_license.pdf',\n * });\n * ```\n */\nexport function encryptDocumentForSDX(\n  document: Buffer,\n  publicKey: string\n): Buffer {\n  const aesKey = crypto.randomBytes(32);\n  const iv = crypto.randomBytes(12);\n\n  const cipher = crypto.createCipheriv('aes-256-gcm', aesKey, iv);\n  const encryptedData = Buffer.concat([\n    cipher.update(document),\n    cipher.final(),\n  ]);\n  const authTag = cipher.getAuthTag();\n\n  const encryptedKey = crypto.publicEncrypt(\n    {\n      key: publicKey,\n      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n      oaepHash: 'sha256',\n    },\n    aesKey\n  );\n\n  const metadata = {\n    encryptedKey: encryptedKey.toString('base64'),\n    iv: iv.toString('base64'),\n    authTag: authTag.toString('base64'),\n  };\n  const metadataBuffer = Buffer.from(JSON.stringify(metadata), 'utf-8');\n\n  // Assemble: [4-byte length][metadata][encrypted data]\n  const result = Buffer.alloc(4 + metadataBuffer.length + encryptedData.length);\n  result.writeUInt32BE(metadataBuffer.length, 0);\n  metadataBuffer.copy(result, 4);\n  encryptedData.copy(result, 4 + metadataBuffer.length);\n\n  return result;\n}\n","import crypto from 'crypto';\nimport type {\n  HybridEncryptedPayload,\n  DecryptedOfferDetails,\n  DecryptionResult,\n  OfferFees,\n} from './types';\n\n/**\n * Decrypt data encrypted with hybrid encryption (AES-256-GCM + RSA-OAEP)\n *\n * @param encryptedPayloadJson - JSON string containing the HybridEncryptedPayload\n * @param privateKeyPem - Your neobank's private key in PEM format\n * @returns Decrypted string data\n *\n * @example\n * ```typescript\n * import { hybridDecrypt } from '@portola/passage-neobank/crypto';\n *\n * const decrypted = hybridDecrypt(\n *   offer.encryptedOfferDetailsNeobank,\n *   process.env.NEOBANK_PRIVATE_KEY!\n * );\n * const offerDetails = JSON.parse(decrypted);\n * console.log(offerDetails.apr); // '12.99%'\n * ```\n */\nexport function hybridDecrypt(\n  encryptedPayloadJson: string,\n  privateKeyPem: string\n): string {\n  // Parse and validate the encrypted payload\n  let payload: HybridEncryptedPayload;\n  try {\n    payload = JSON.parse(encryptedPayloadJson);\n  } catch {\n    throw new Error('Invalid encrypted payload: malformed JSON');\n  }\n\n  // Validate required fields\n  if (\n    typeof payload.encryptedData !== 'string' ||\n    typeof payload.encryptedKey !== 'string' ||\n    typeof payload.iv !== 'string' ||\n    typeof payload.authTag !== 'string'\n  ) {\n    throw new Error(\n      'Invalid encrypted payload: missing required fields (encryptedData, encryptedKey, iv, authTag)'\n    );\n  }\n\n  // Decode base64 components\n  const encryptedKey = Buffer.from(payload.encryptedKey, 'base64');\n  const iv = Buffer.from(payload.iv, 'base64');\n  const authTag = Buffer.from(payload.authTag, 'base64');\n  const encryptedData = Buffer.from(payload.encryptedData, 'base64');\n\n  // Decrypt AES key with RSA-OAEP\n  const aesKey = crypto.privateDecrypt(\n    {\n      key: privateKeyPem,\n      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n      oaepHash: 'sha256',\n    },\n    encryptedKey\n  );\n\n  // Decrypt data with AES-256-GCM\n  const decipher = crypto.createDecipheriv('aes-256-gcm', aesKey, iv);\n  decipher.setAuthTag(authTag);\n\n  const decrypted = Buffer.concat([\n    decipher.update(encryptedData),\n    decipher.final(),\n  ]);\n\n  return decrypted.toString('utf-8');\n}\n\n/**\n * Decrypt and verify offer details\n *\n * Decrypts the encrypted offer details and verifies integrity using the checksum.\n *\n * @param encryptedPayload - The encrypted payload from offer.encryptedOfferDetailsNeobank\n * @param expectedChecksum - The checksum from offer.checksumSha256\n * @param privateKeyPem - Your neobank's private key in PEM format\n * @returns DecryptionResult with data, checksum, and verification status\n *\n * @example\n * ```typescript\n * import { decryptOfferDetails } from '@portola/passage-neobank/crypto';\n *\n * const offers = await passage.offers.getPrequalified(applicationId);\n *\n * for (const lenderGroup of offers.lenders) {\n *   for (const offer of lenderGroup.offers) {\n *     const result = decryptOfferDetails(\n *       offer.encryptedOfferDetailsNeobank,\n *       offer.checksumSha256,\n *       process.env.NEOBANK_PRIVATE_KEY!\n *     );\n *\n *     if (!result.verified) {\n *       console.warn(`Offer ${offer.offerId} failed integrity check`);\n *       continue;\n *     }\n *\n *     console.log(`APR: ${result.data.apr}`);\n *     console.log(`Monthly Payment: ${result.data.monthlyPayment}`);\n *   }\n * }\n * ```\n */\n/** Known fields in DecryptedOfferDetails (used to separate additionalFields) */\nconst KNOWN_OFFER_FIELDS = new Set([\n  'apr',\n  'interestRate',\n  'term',\n  'monthlyPayment',\n  'totalRepayment',\n  'originationFee',\n  'originationFeePercent',\n  'prepaymentPenalty',\n  'latePaymentFee',\n  'fees',\n  'offerDetails',\n]);\n\nexport function decryptOfferDetails(\n  encryptedPayload: string,\n  expectedChecksum: string,\n  privateKeyPem: string\n): DecryptionResult<DecryptedOfferDetails> {\n  // Calculate checksum of the ENCRYPTED payload (before decryption)\n  // This matches how lenders compute checksums when submitting offers:\n  // - Lender encrypts offer details with neobank's public key\n  // - Lender computes SHA-256 of the encrypted blob\n  // - Neobank verifies the encrypted blob wasn't tampered in transit\n  const checksum = crypto\n    .createHash('sha256')\n    .update(encryptedPayload, 'utf8')\n    .digest('hex');\n\n  const decrypted = hybridDecrypt(encryptedPayload, privateKeyPem);\n  const rawData = JSON.parse(decrypted) as Record<string, unknown>;\n\n  // Separate known fields from lender-specific additional fields\n  const additionalFields: Record<string, unknown> = {};\n  for (const key of Object.keys(rawData)) {\n    if (!KNOWN_OFFER_FIELDS.has(key)) {\n      additionalFields[key] = rawData[key];\n    }\n  }\n\n  // Extract fees - core API sends as OfferFees or null\n  const fees = rawData.fees as OfferFees | null | undefined;\n\n  // Extract offerDetails - lender-specific metadata\n  const offerDetailsField = rawData.offerDetails as\n    | Record<string, unknown>\n    | undefined;\n\n  const data: DecryptedOfferDetails = {\n    apr: rawData.apr as string | undefined,\n    interestRate: rawData.interestRate as string,\n    term: rawData.term as number,\n    monthlyPayment: rawData.monthlyPayment as string,\n    totalRepayment: rawData.totalRepayment as string | undefined,\n    // Include structured fees and offerDetails from core API\n    fees: fees,\n    offerDetails: offerDetailsField,\n    // Keep deprecated flat fields for backwards compatibility\n    originationFee: rawData.originationFee as string | undefined,\n    originationFeePercent: rawData.originationFeePercent as string | undefined,\n    prepaymentPenalty: rawData.prepaymentPenalty as boolean | undefined,\n    latePaymentFee: rawData.latePaymentFee as string | undefined,\n    ...(Object.keys(additionalFields).length > 0 && { additionalFields }),\n  };\n\n  return {\n    data,\n    checksum,\n    verified: checksum === expectedChecksum,\n  };\n}\n\n/**\n * Result of batch offer decryption\n */\nexport type BatchDecryptResult<T> =\n  | {\n      offer: T;\n      details: DecryptedOfferDetails;\n      verified: boolean;\n      error?: undefined;\n    }\n  | { offer: T; details: null; verified: false; error: string };\n\n/**\n * Batch decrypt multiple offers\n *\n * Convenience function to decrypt all offers at once.\n *\n * @param offers - Array of offers with encryptedOfferDetailsNeobank and checksumSha256\n * @param privateKeyPem - Your neobank's private key in PEM format\n * @returns Array of decryption results with original offer reference\n *\n * @example\n * ```typescript\n * import { decryptOffers } from '@portola/passage-neobank/crypto';\n *\n * const offersResponse = await passage.offers.getPrequalified(applicationId);\n * const allOffers = offersResponse.lenders.flatMap(l => l.offers);\n *\n * const decryptedOffers = decryptOffers(allOffers, process.env.NEOBANK_PRIVATE_KEY!);\n *\n * // Filter to only successfully decrypted offers and sort by APR\n * const validOffers = decryptedOffers\n *   .filter((o): o is typeof o & { details: DecryptedOfferDetails } => o.details !== null && o.verified)\n *   .sort((a, b) => parseFloat(a.details.apr) - parseFloat(b.details.apr));\n *\n * // Log any decryption errors\n * decryptedOffers\n *   .filter(o => o.error)\n *   .forEach(o => console.warn(`Failed to decrypt offer: ${o.error}`));\n *\n * console.log(`Best APR: ${validOffers[0]?.details.apr}`);\n * ```\n */\nexport function decryptOffers<\n  T extends { encryptedOfferDetailsNeobank: string; checksumSha256: string },\n>(offers: T[], privateKeyPem: string): Array<BatchDecryptResult<T>> {\n  return offers.map((offer) => {\n    try {\n      const result = decryptOfferDetails(\n        offer.encryptedOfferDetailsNeobank,\n        offer.checksumSha256,\n        privateKeyPem\n      );\n      return {\n        offer,\n        details: result.data,\n        verified: result.verified,\n      };\n    } catch (error) {\n      // Return null details with error message on decryption failure\n      return {\n        offer,\n        details: null,\n        verified: false as const,\n        error:\n          error instanceof Error ? error.message : 'Unknown decryption error',\n      };\n    }\n  });\n}\n"]}