{"version":3,"sources":["../../src/errors.ts","../../src/webhooks/handler.ts"],"names":["crypto"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Base error class for all Passage SDK errors\n */\nexport class PassageError extends Error {\n  /** HTTP status code (if applicable) */\n  readonly statusCode?: number;\n  /** API error code (e.g., 'NOT_FOUND', 'VALIDATION_ERROR') */\n  readonly errorCode?: string;\n  /** Request ID for support debugging */\n  readonly requestId?: string;\n  /** Original error details from API */\n  readonly details?: unknown;\n  /** Original cause error */\n  readonly cause?: Error;\n\n  constructor(\n    message: string,\n    options?: {\n      statusCode?: number;\n      errorCode?: string;\n      requestId?: string;\n      details?: unknown;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'PassageError';\n    this.statusCode = options?.statusCode;\n    this.errorCode = options?.errorCode;\n    this.requestId = options?.requestId;\n    this.details = options?.details;\n    this.cause = options?.cause;\n\n    // Maintain proper stack trace in V8 environments\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  /**\n   * Check if this is a specific error type\n   */\n  is(errorCode: string): boolean {\n    return this.errorCode === errorCode;\n  }\n\n  /**\n   * Check if error is retryable (5xx or network errors)\n   */\n  get isRetryable(): boolean {\n    if (!this.statusCode) return true; // Network errors are retryable\n    return this.statusCode >= 500 || this.statusCode === 429;\n  }\n\n  /**\n   * Check if error is a client error (4xx)\n   */\n  get isClientError(): boolean {\n    return (\n      this.statusCode !== undefined &&\n      this.statusCode >= 400 &&\n      this.statusCode < 500\n    );\n  }\n\n  /**\n   * Check if error is a server error (5xx)\n   */\n  get isServerError(): boolean {\n    return this.statusCode !== undefined && this.statusCode >= 500;\n  }\n}\n\n/**\n * Validation error with field-level details\n */\nexport class ValidationError extends PassageError {\n  /** Field-specific validation errors */\n  readonly fields?: Record<string, string[]>;\n\n  constructor(\n    message: string,\n    fields?: Record<string, string[]>,\n    options?: {\n      requestId?: string;\n      details?: unknown;\n    }\n  ) {\n    super(message, {\n      statusCode: 400,\n      errorCode: 'VALIDATION_ERROR',\n      requestId: options?.requestId,\n      details: options?.details,\n    });\n    this.name = 'ValidationError';\n    this.fields = fields;\n  }\n\n  /**\n   * Get errors for a specific field\n   */\n  getFieldErrors(field: string): string[] {\n    return this.fields?.[field] ?? [];\n  }\n\n  /**\n   * Check if a specific field has errors\n   */\n  hasFieldError(field: string): boolean {\n    return (this.fields?.[field]?.length ?? 0) > 0;\n  }\n}\n\n/**\n * Authentication error (invalid or expired API key)\n */\nexport class AuthenticationError extends PassageError {\n  constructor(\n    message: string = 'Invalid or expired API key',\n    requestId?: string\n  ) {\n    super(message, {\n      statusCode: 401,\n      errorCode: 'AUTHENTICATION_ERROR',\n      requestId,\n    });\n    this.name = 'AuthenticationError';\n  }\n}\n\n/**\n * Authorization error (insufficient permissions)\n */\nexport class AuthorizationError extends PassageError {\n  constructor(\n    message: string = 'Insufficient permissions for this action',\n    requestId?: string\n  ) {\n    super(message, {\n      statusCode: 403,\n      errorCode: 'AUTHORIZATION_ERROR',\n      requestId,\n    });\n    this.name = 'AuthorizationError';\n  }\n}\n\n/**\n * Resource not found error\n */\nexport class NotFoundError extends PassageError {\n  /** The type of resource that wasn't found */\n  readonly resourceType?: string;\n  /** The ID that was looked up */\n  readonly resourceId?: string;\n\n  constructor(\n    message: string,\n    options?: {\n      resourceType?: string;\n      resourceId?: string;\n      requestId?: string;\n    }\n  ) {\n    super(message, {\n      statusCode: 404,\n      errorCode: 'NOT_FOUND',\n      requestId: options?.requestId,\n    });\n    this.name = 'NotFoundError';\n    this.resourceType = options?.resourceType;\n    this.resourceId = options?.resourceId;\n  }\n}\n\n/**\n * Rate limit exceeded error\n */\nexport class RateLimitError extends PassageError {\n  /** When the rate limit resets (Unix timestamp) */\n  readonly retryAfter?: number;\n\n  constructor(\n    message: string = 'Rate limit exceeded',\n    retryAfter?: number,\n    requestId?: string\n  ) {\n    super(message, {\n      statusCode: 429,\n      errorCode: 'RATE_LIMIT_EXCEEDED',\n      requestId,\n    });\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter;\n  }\n}\n\n/**\n * Conflict error (e.g., duplicate resource, invalid state transition)\n */\nexport class ConflictError extends PassageError {\n  constructor(message: string, requestId?: string) {\n    super(message, {\n      statusCode: 409,\n      errorCode: 'CONFLICT',\n      requestId,\n    });\n    this.name = 'ConflictError';\n  }\n}\n\n/**\n * Network or connection error\n */\nexport class NetworkError extends PassageError {\n  constructor(message: string = 'Network error', cause?: Error) {\n    super(message, {\n      errorCode: 'NETWORK_ERROR',\n      cause,\n    });\n    this.name = 'NetworkError';\n  }\n}\n\n/**\n * Request timeout error\n */\nexport class TimeoutError extends PassageError {\n  constructor(message: string = 'Request timed out', cause?: Error) {\n    super(message, {\n      errorCode: 'TIMEOUT',\n      cause,\n    });\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Create appropriate error from API response\n *\n * API returns errors in this format:\n * {\n *   error: 'NOT_FOUND' | 'VALIDATION_ERROR' | etc,\n *   message: 'Human readable message',\n *   status: 404,\n *   requestId: 'req_...',\n *   details?: [{field: 'fieldName', message: 'error'}]  // For validation errors\n * }\n */\nexport function createErrorFromResponse(\n  statusCode: number,\n  body: {\n    error?: string;\n    message?: string;\n    code?: string;\n    status?: number;\n    requestId?: string;\n    // API format: array of {field, message}\n    details?: Array<{ field: string; message: string }>;\n    // Legacy SDK format: Record<string, string[]>\n    fields?: Record<string, string[]>;\n  }\n): PassageError {\n  const message = body.message || body.error || 'Unknown error';\n  const requestId = body.requestId;\n  // API uses 'error' field for error code, SDK used 'code'\n  const errorCode = body.error || body.code;\n\n  switch (statusCode) {\n    case 400:\n      // Handle validation errors - convert API format to SDK format\n      if (body.details && Array.isArray(body.details)) {\n        // Convert [{field, message}] to {field: [message]}\n        const fields: Record<string, string[]> = {};\n        for (const detail of body.details) {\n          if (!fields[detail.field]) {\n            fields[detail.field] = [];\n          }\n          fields[detail.field].push(detail.message);\n        }\n        return new ValidationError(message, fields, { requestId });\n      }\n      // Legacy format support\n      if (body.fields) {\n        return new ValidationError(message, body.fields, { requestId });\n      }\n      // Create ValidationError when error code indicates it, even without details\n      if (errorCode === 'VALIDATION_ERROR') {\n        return new ValidationError(message, undefined, { requestId });\n      }\n      return new PassageError(message, {\n        statusCode: 400,\n        errorCode: errorCode || 'BAD_REQUEST',\n        requestId,\n      });\n\n    case 401:\n      return new AuthenticationError(message, requestId);\n\n    case 403:\n      return new AuthorizationError(message, requestId);\n\n    case 404:\n      return new NotFoundError(message, { requestId });\n\n    case 409:\n      return new ConflictError(message, requestId);\n\n    case 429:\n      return new RateLimitError(message, undefined, requestId);\n\n    default:\n      return new PassageError(message, {\n        statusCode,\n        errorCode: errorCode || `HTTP_${statusCode}`,\n        requestId,\n        details: body,\n      });\n  }\n}\n","import crypto from 'crypto';\nimport type { WebhookEvent, WebhookEventType } from './types';\nimport { PassageError } from '../errors';\n\n/**\n * Configuration for the webhook handler\n */\nexport interface WebhookHandlerConfig {\n  /** Webhook signing secret (starts with whsec_) */\n  secret: string;\n  /** Tolerance for timestamp validation in seconds (default: 300 = 5 minutes) */\n  tolerance?: number;\n}\n\n/**\n * Error thrown when webhook signature verification fails\n */\nexport class WebhookSignatureError extends PassageError {\n  constructor(message: string) {\n    super(message, {\n      errorCode: 'WEBHOOK_SIGNATURE_INVALID',\n    });\n    this.name = 'WebhookSignatureError';\n  }\n}\n\n/**\n * Webhook handler for verifying and parsing Passage webhooks\n *\n * @example\n * ```typescript\n * import { WebhookHandler } from '@portola/passage-neobank/webhooks';\n *\n * const webhooks = new WebhookHandler({\n *   secret: process.env.WEBHOOK_SECRET!,\n * });\n *\n * // In your webhook endpoint (e.g., Next.js API route)\n * export async function POST(req: Request) {\n *   const body = await req.text();\n *   const signature = req.headers.get('x-passage-signature')!;\n *\n *   try {\n *     const event = webhooks.constructEvent(body, signature);\n *\n *     switch (event.event) {\n *       case 'application.status.changed':\n *         console.log('Application status changed:', event.data);\n *         break;\n *       case 'loan.funded':\n *         console.log('Loan funded:', event.data);\n *         break;\n *     }\n *\n *     return new Response('OK', { status: 200 });\n *   } catch (error) {\n *     if (error instanceof WebhookSignatureError) {\n *       return new Response('Invalid signature', { status: 401 });\n *     }\n *     throw error;\n *   }\n * }\n * ```\n */\nexport class WebhookHandler {\n  private secret: string;\n  private tolerance: number;\n\n  constructor(config: WebhookHandlerConfig) {\n    if (!config.secret) {\n      throw new Error('WebhookHandler: secret is required');\n    }\n    this.secret = config.secret;\n    this.tolerance = config.tolerance ?? 300; // 5 minutes default\n  }\n\n  /**\n   * Verify signature and construct webhook event\n   *\n   * @param payload - Raw request body as string\n   * @param signature - Value of x-passage-signature header\n   * @returns Parsed and verified webhook event\n   * @throws WebhookSignatureError if signature is invalid\n   */\n  constructEvent<T = unknown>(payload: string, signature: string): WebhookEvent<T> {\n    this.verifySignature(payload, signature);\n    return JSON.parse(payload) as WebhookEvent<T>;\n  }\n\n  /**\n   * Verify webhook signature\n   *\n   * @param payload - Raw request body as string\n   * @param signature - Value of x-passage-signature header\n   * @throws WebhookSignatureError if signature is invalid\n   */\n  verifySignature(payload: string, signature: string): void {\n    if (!signature) {\n      throw new WebhookSignatureError('Missing signature header');\n    }\n\n    // Parse signature header: t=timestamp,v1=signature\n    const parts = signature.split(',');\n    const timestamp = parts.find((p) => p.startsWith('t='))?.slice(2);\n    const sig = parts.find((p) => p.startsWith('v1='))?.slice(3);\n\n    if (!timestamp || !sig) {\n      throw new WebhookSignatureError('Invalid signature format');\n    }\n\n    // Verify timestamp is within tolerance\n    const timestampNum = parseInt(timestamp, 10);\n    const now = Math.floor(Date.now() / 1000);\n\n    if (Math.abs(now - timestampNum) > this.tolerance) {\n      throw new WebhookSignatureError('Timestamp outside tolerance window');\n    }\n\n    // Compute expected signature\n    const signedPayload = `${timestamp}.${payload}`;\n    const expectedSig = crypto\n      .createHmac('sha256', this.secret)\n      .update(signedPayload)\n      .digest('hex');\n\n    // Timing-safe comparison\n    // Note: Must check buffer lengths first - timingSafeEqual throws if lengths differ\n    const sigBuffer = Buffer.from(sig, 'hex');\n    const expectedSigBuffer = Buffer.from(expectedSig, 'hex');\n\n    if (\n      sigBuffer.length !== expectedSigBuffer.length ||\n      !crypto.timingSafeEqual(sigBuffer, expectedSigBuffer)\n    ) {\n      throw new WebhookSignatureError('Signature verification failed');\n    }\n  }\n\n  /**\n   * Generate test headers for webhook testing\n   *\n   * Useful for writing unit tests for your webhook handlers.\n   *\n   * @param payload - The webhook payload to sign\n   * @returns Object with x-passage-signature header value\n   *\n   * @example\n   * ```typescript\n   * // In your tests\n   * const webhooks = new WebhookHandler({ secret: 'test_secret' });\n   *\n   * const testPayload = JSON.stringify({\n   *   id: 'evt_123',\n   *   event: 'application.status.changed',\n   *   data: { applicationId: 'app_123', newStatus: 'OFFERS_READY' },\n   *   timestamp: new Date().toISOString(),\n   *   version: '1.0',\n   * });\n   *\n   * const headers = webhooks.generateTestHeaders(testPayload);\n   *\n   * // Use in your test\n   * const response = await fetch('/api/webhooks', {\n   *   method: 'POST',\n   *   body: testPayload,\n   *   headers: {\n   *     'Content-Type': 'application/json',\n   *     'x-passage-signature': headers['x-passage-signature'],\n   *   },\n   * });\n   * ```\n   */\n  generateTestHeaders(payload: string): { 'x-passage-signature': string } {\n    const timestamp = Math.floor(Date.now() / 1000);\n    const signedPayload = `${timestamp}.${payload}`;\n    const signature = crypto.createHmac('sha256', this.secret).update(signedPayload).digest('hex');\n\n    return {\n      'x-passage-signature': `t=${timestamp},v1=${signature}`,\n    };\n  }\n}\n"]}