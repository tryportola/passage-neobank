{"version":3,"sources":["../../src/resources/wallets.ts"],"names":[],"mappings":";;;AAuGO,SAAS,gBACd,SAAA,EAC4B;AAC5B,EAAA,OAAO,SAAA,IAAa,SAAA;AACtB;AAKO,SAAS,uBACd,SAAA,EACmC;AACnC,EAAA,OAAO,OAAA,IAAW,aAAa,iBAAA,IAAqB,SAAA;AACtD","file":"index.js","sourcesContent":["import type { WalletsApi } from '@portola/passage';\nimport type {\n  WalletResponseData,\n  WalletType,\n  WalletVerificationMethod,\n  WalletVerificationStatus,\n  Chain,\n  WalletChain,\n} from '@portola/passage';\nimport type { ResolvedConfig } from '../config';\nimport { BaseResource, unwrapResponse } from './base';\n\n// Re-export types for convenience\nexport type { WalletVerificationMethod, WalletVerificationStatus, Chain, WalletChain };\n// Note: WalletType is also exported but users can import from @portola/passage directly\n\n/**\n * Wallet data returned from the API\n */\nexport interface Wallet {\n  id: string;\n  address: string;\n  chain: Chain;\n  type: WalletType;\n  verified: boolean;\n  verifiedByThisNeobank: boolean;\n  verifiedAt: string | null;\n  verificationMethod: WalletVerificationMethod | null;\n  externalId: string | null;\n  label: string | null;\n  createdAt: string;\n}\n\n/**\n * Parameters for creating/registering a wallet\n */\nexport interface CreateWalletParams {\n  address: string;\n  /** Blockchain chain for the wallet (e.g., 'base', 'ethereum', 'polygon') */\n  chain?: WalletChain;\n  type?: WalletType;\n  externalId?: string;\n  label?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Parameters for updating wallet metadata\n */\nexport interface UpdateWalletParams {\n  externalId?: string;\n  label?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Parameters for listing wallets\n */\nexport interface ListWalletsParams {\n  verified?: boolean;\n  chain?: Chain;\n  externalId?: string;\n  address?: string;\n  limit?: number;\n  offset?: number;\n}\n\n/**\n * MESSAGE_SIGN challenge structure\n */\nexport interface MessageSignChallenge {\n  message: string;\n  nonce: string;\n  signingStandard: 'personal_sign' | 'eth_signTypedData_v4';\n  typedData?: Record<string, unknown>;\n}\n\n/**\n * AOPP challenge structure\n */\nexport interface AOPPChallenge {\n  callback: string;\n  message: string;\n  asset: string;\n  format?: string;\n  aoppUri: string;\n}\n\n/**\n * Verification challenge data\n */\nexport interface VerificationChallenge {\n  verificationId: string;\n  walletId: string;\n  method: WalletVerificationMethod;\n  status: WalletVerificationStatus;\n  challenge: MessageSignChallenge | AOPPChallenge;\n  expiresAt: string;\n}\n\n/**\n * Type guard to check if challenge is AOPP\n */\nexport function isAOPPChallenge(\n  challenge: MessageSignChallenge | AOPPChallenge\n): challenge is AOPPChallenge {\n  return 'aoppUri' in challenge;\n}\n\n/**\n * Type guard to check if challenge is MESSAGE_SIGN\n */\nexport function isMessageSignChallenge(\n  challenge: MessageSignChallenge | AOPPChallenge\n): challenge is MessageSignChallenge {\n  return 'nonce' in challenge && 'signingStandard' in challenge;\n}\n\n/**\n * Verification status data\n */\nexport interface Verification {\n  id: string;\n  walletId: string;\n  method: WalletVerificationMethod;\n  status: WalletVerificationStatus;\n  expiresAt: string | null;\n  completedAt: string | null;\n  failedAt: string | null;\n  failureReason: string | null;\n}\n\n/**\n * Verification list item\n */\nexport interface VerificationSummary {\n  id: string;\n  method: WalletVerificationMethod;\n  status: WalletVerificationStatus;\n  initiatedAt: string;\n  completedAt: string | null;\n  expiresAt: string;\n}\n\n/**\n * Result of submitting verification proof\n */\nexport interface VerificationResult {\n  verificationId: string;\n  status: WalletVerificationStatus;\n  verifiedAt: string | null;\n  wallet: {\n    id: string;\n    verified: boolean;\n    verificationMethod: WalletVerificationMethod | null;\n  };\n}\n\n/**\n * Resource for wallet ownership verification\n *\n * @example\n * ```typescript\n * // Register a wallet\n * const wallet = await passage.wallets.create({\n *   address: '0x1234...',\n *   chain: 'base',\n * });\n *\n * // Initiate verification\n * const challenge = await passage.wallets.initiateVerification(wallet.id, {\n *   method: 'MESSAGE_SIGN',\n * });\n *\n * // User signs the message with their wallet\n * const signature = await userWallet.signMessage(challenge.challenge.message);\n *\n * // Submit the proof\n * const result = await passage.wallets.submitProof(challenge.verificationId, {\n *   signature,\n * });\n *\n * console.log(result.status); // 'VERIFIED'\n * ```\n */\nexport class WalletsResource extends BaseResource {\n  private api: WalletsApi;\n\n  constructor(api: WalletsApi, config: ResolvedConfig) {\n    super(config);\n    this.api = api;\n  }\n\n  /**\n   * Create or link a wallet\n   *\n   * Registers a wallet address for ownership verification.\n   * Idempotent - returns existing wallet if address+chain already exists.\n   *\n   * @example\n   * ```typescript\n   * const wallet = await passage.wallets.create({\n   *   address: '0x1234567890abcdef...',\n   *   chain: 'base',\n   *   externalId: 'user_123', // Your internal user ID\n   *   label: \"John's wallet\",\n   * });\n   * ```\n   */\n  async create(params: CreateWalletParams): Promise<Wallet> {\n    return this.execute(async () => {\n      this.debug('wallets.create', params.address);\n\n      const response = await this.api.createWallet({\n        createWalletRequest: {\n          address: params.address,\n          chain: params.chain,\n          type: params.type,\n          externalId: params.externalId,\n          label: params.label,\n          metadata: params.metadata,\n        },\n      });\n\n      const data = unwrapResponse(response);\n      return this.mapWallet(data);\n    }, 'wallets.create');\n  }\n\n  /**\n   * Get a wallet by ID\n   *\n   * @example\n   * ```typescript\n   * const wallet = await passage.wallets.get('wal_123');\n   * console.log(wallet.verified, wallet.verifiedByThisNeobank);\n   * ```\n   */\n  async get(walletId: string): Promise<Wallet> {\n    return this.execute(async () => {\n      this.debug('wallets.get', walletId);\n\n      const response = await this.api.getWallet({ id: walletId });\n      const data = unwrapResponse(response);\n      return this.mapWallet(data);\n    }, 'wallets.get');\n  }\n\n  /**\n   * List wallets linked to this neobank\n   *\n   * @example\n   * ```typescript\n   * // List all verified wallets\n   * const { wallets } = await passage.wallets.list({ verified: true });\n   *\n   * // Find wallets by external ID\n   * const { wallets } = await passage.wallets.list({ externalId: 'user_123' });\n   * ```\n   */\n  async list(params: ListWalletsParams = {}): Promise<{\n    wallets: Wallet[];\n    pagination: { total: number; limit: number; offset: number };\n  }> {\n    return this.execute(async () => {\n      this.debug('wallets.list', params);\n\n      // API expects 'true' | 'false' string instead of boolean for verified filter\n      const verifiedParam = params.verified === undefined\n        ? undefined\n        : params.verified\n          ? ('true' as const)\n          : ('false' as const);\n\n      const response = await this.api.listWallets({\n        verified: verifiedParam,\n        chain: params.chain as 'base' | 'ethereum' | 'polygon' | 'arbitrum' | 'optimism' | 'solana' | undefined,\n        externalId: params.externalId,\n        address: params.address,\n        limit: params.limit,\n        offset: params.offset,\n      });\n\n      const data = unwrapResponse(response);\n      return {\n        wallets: data.wallets.map((w: WalletResponseData) => this.mapWallet(w)),\n        pagination: data.pagination,\n      };\n    }, 'wallets.list');\n  }\n\n  /**\n   * Update wallet metadata\n   *\n   * Updates neobank-specific metadata (externalId, label, metadata).\n   *\n   * @example\n   * ```typescript\n   * await passage.wallets.update('wal_123', {\n   *   label: 'Primary wallet',\n   *   externalId: 'new_user_id',\n   * });\n   * ```\n   */\n  async update(walletId: string, params: UpdateWalletParams): Promise<Wallet> {\n    return this.execute(async () => {\n      this.debug('wallets.update', walletId);\n\n      const response = await this.api.updateWallet({\n        id: walletId,\n        updateWalletRequest: {\n          externalId: params.externalId,\n          label: params.label,\n          metadata: params.metadata,\n        },\n      });\n\n      const data = unwrapResponse(response);\n      return this.mapWallet(data);\n    }, 'wallets.update');\n  }\n\n  /**\n   * Initiate wallet verification\n   *\n   * Starts the verification process. For MESSAGE_SIGN, returns a message\n   * that the user must sign with their wallet.\n   *\n   * @example\n   * ```typescript\n   * const challenge = await passage.wallets.initiateVerification('wal_123', {\n   *   method: 'MESSAGE_SIGN',\n   * });\n   *\n   * // Present message to user for signing\n   * console.log(challenge.challenge.message);\n   * ```\n   */\n  async initiateVerification(\n    walletId: string,\n    params: { method: WalletVerificationMethod }\n  ): Promise<VerificationChallenge> {\n    return this.execute(async () => {\n      this.debug('wallets.initiateVerification', walletId, params.method);\n\n      const response = await this.api.initiateVerification({\n        walletId,\n        initiateVerificationRequest: { method: params.method },\n      });\n\n      const data = unwrapResponse(response);\n      return {\n        verificationId: data.verificationId,\n        walletId: data.walletId,\n        method: data.method as WalletVerificationMethod,\n        status: data.status as WalletVerificationStatus,\n        challenge: data.challenge,\n        expiresAt: data.expiresAt,\n      };\n    }, 'wallets.initiateVerification');\n  }\n\n  /**\n   * Submit verification proof\n   *\n   * Submits the signature to complete verification.\n   *\n   * @example\n   * ```typescript\n   * // After user signs the challenge message\n   * const result = await passage.wallets.submitProof(verificationId, {\n   *   signature: '0x...',\n   * });\n   *\n   * if (result.status === 'VERIFIED') {\n   *   console.log('Wallet verified!');\n   * }\n   * ```\n   */\n  async submitProof(\n    verificationId: string,\n    params: { signature: string }\n  ): Promise<VerificationResult> {\n    return this.execute(async () => {\n      this.debug('wallets.submitProof', verificationId);\n\n      const response = await this.api.submitVerificationProof({\n        verificationId,\n        submitProofRequest: { signature: params.signature },\n      });\n\n      const data = unwrapResponse(response);\n      return {\n        verificationId: data.verificationId,\n        status: data.status,\n        verifiedAt: data.verifiedAt,\n        wallet: {\n          id: data.wallet.id,\n          verified: data.wallet.verified,\n          verificationMethod: data.wallet.verificationMethod,\n        },\n      };\n    }, 'wallets.submitProof');\n  }\n\n  /**\n   * Get verification status\n   *\n   * @example\n   * ```typescript\n   * const verification = await passage.wallets.getVerification('ver_123');\n   * console.log(verification.status);\n   * ```\n   */\n  async getVerification(verificationId: string): Promise<Verification> {\n    return this.execute(async () => {\n      this.debug('wallets.getVerification', verificationId);\n\n      const response = await this.api.getVerificationStatus({ verificationId });\n      const data = unwrapResponse(response);\n\n      return {\n        id: data.id,\n        walletId: data.walletId,\n        method: data.method as WalletVerificationMethod,\n        status: data.status as WalletVerificationStatus,\n        expiresAt: data.expiresAt ?? null,\n        completedAt: data.completedAt,\n        failedAt: data.failedAt,\n        failureReason: data.failureReason,\n      };\n    }, 'wallets.getVerification');\n  }\n\n  /**\n   * List verifications for a wallet\n   *\n   * Returns all verification attempts for this wallet by this neobank.\n   *\n   * @example\n   * ```typescript\n   * const { verifications } = await passage.wallets.listVerifications('wal_123');\n   * ```\n   */\n  async listVerifications(walletId: string): Promise<{\n    verifications: VerificationSummary[];\n  }> {\n    return this.execute(async () => {\n      this.debug('wallets.listVerifications', walletId);\n\n      const response = await this.api.listWalletVerifications({ walletId });\n      const data = unwrapResponse(response);\n\n      return {\n        verifications: data.verifications.map((v) => ({\n          id: v.id,\n          method: v.method as WalletVerificationMethod,\n          status: v.status as WalletVerificationStatus,\n          initiatedAt: v.initiatedAt,\n          completedAt: v.completedAt ?? null,\n          expiresAt: v.expiresAt,\n        })),\n      };\n    }, 'wallets.listVerifications');\n  }\n\n  // =========================================================================\n  // Convenience Methods\n  // =========================================================================\n\n  /**\n   * Ensure a wallet is registered and check verification status\n   *\n   * This is a convenience method that:\n   * 1. Creates/links the wallet if it doesn't exist\n   * 2. Checks if already verified by this neobank\n   * 3. Returns verification status and challenge if needed\n   *\n   * Use this when you want to check if a wallet needs verification\n   * before showing the signing UI to the user.\n   *\n   * @example\n   * ```typescript\n   * const result = await passage.wallets.ensureVerified({\n   *   address: userWalletAddress,\n   *   chain: 'base',\n   *   externalId: user.id,\n   * });\n   *\n   * if (result.verified) {\n   *   // Wallet already verified, proceed with application\n   *   console.log('Wallet verified:', result.wallet.id);\n   * } else {\n   *   // Need user to sign - show signing UI\n   *   const signature = await walletClient.signMessage({\n   *     message: result.challenge.challenge.message,\n   *   });\n   *\n   *   await passage.wallets.submitProof(result.challenge.verificationId, { signature });\n   * }\n   * ```\n   */\n  async ensureVerified(params: CreateWalletParams): Promise<\n    | { verified: true; wallet: Wallet; challenge: null }\n    | { verified: false; wallet: Wallet; challenge: VerificationChallenge }\n  > {\n    return this.execute(async () => {\n      this.debug('wallets.ensureVerified', params.address);\n\n      // 1. Create or get existing wallet\n      const wallet = await this.create(params);\n\n      // 2. If already verified by this neobank, return immediately\n      if (wallet.verifiedByThisNeobank) {\n        return { verified: true, wallet, challenge: null };\n      }\n\n      // 3. Not verified - initiate verification and return challenge\n      const challenge = await this.initiateVerification(wallet.id, {\n        method: 'MESSAGE_SIGN',\n      });\n\n      return { verified: false, wallet, challenge };\n    }, 'wallets.ensureVerified');\n  }\n\n  /**\n   * Register wallet and complete verification in a single atomic operation\n   *\n   * This method creates a NEW challenge internally and verifies the signature\n   * against that challenge. It is designed for server-controlled signing\n   * scenarios (custodial wallets, automated systems) where you can sign the\n   * challenge message in the same execution context.\n   *\n   * **WARNING:** Do NOT use this after calling `ensureVerified()` or\n   * `initiateVerification()`. Each call creates a new challenge with a unique\n   * nonce, so signatures from previous challenges will fail verification.\n   *\n   * For browser-based user wallet verification, use the two-step flow:\n   * 1. Call `ensureVerified()` to get the challenge\n   * 2. User signs the challenge message in their wallet\n   * 3. Call `submitProof(challenge.verificationId, { signature })`\n   *\n   * @example\n   * ```typescript\n   * // For custodial/server-controlled wallets only\n   * const result = await passage.wallets.verifyWithSignature({\n   *   address: custodialWalletAddress,\n   *   chain: 'base',\n   *   signature: await custodialSigner.signMessage(challengeMessage),\n   * });\n   *\n   * console.log(result.wallet.verified); // true\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // For browser-based user wallets, use ensureVerified + submitProof instead:\n   * const result = await passage.wallets.ensureVerified({ address: '0x...' });\n   * if (!result.verified) {\n   *   const signature = await userWallet.signMessage(result.challenge.challenge.message);\n   *   await passage.wallets.submitProof(result.challenge.verificationId, { signature });\n   * }\n   * ```\n   */\n  async verifyWithSignature(\n    params: CreateWalletParams & { signature: string }\n  ): Promise<VerificationResult & { wallet: Wallet }> {\n    return this.execute(async () => {\n      this.debug('wallets.verifyWithSignature', params.address);\n\n      const { signature, ...walletParams } = params;\n\n      // 1. Create or get existing wallet\n      const wallet = await this.create(walletParams);\n\n      // 2. If already verified, return current state\n      if (wallet.verifiedByThisNeobank) {\n        return {\n          verificationId: '', // No new verification created\n          status: 'VERIFIED' as const,\n          verifiedAt: wallet.verifiedAt,\n          wallet,\n        };\n      }\n\n      // 3. Initiate verification\n      const challenge = await this.initiateVerification(wallet.id, {\n        method: 'MESSAGE_SIGN',\n      });\n\n      // 4. Submit proof\n      const result = await this.submitProof(challenge.verificationId, { signature });\n\n      // 5. Return result with updated wallet\n      const updatedWallet = await this.get(wallet.id);\n\n      return {\n        ...result,\n        wallet: updatedWallet,\n      };\n    }, 'wallets.verifyWithSignature');\n  }\n\n  // =========================================================================\n  // AOPP Methods\n  // =========================================================================\n\n  /**\n   * Initiate AOPP verification\n   *\n   * Returns a challenge with an aoppUri that can be displayed as a QR code.\n   * The user scans this with an AOPP-compatible wallet (Ledger Live, BitBox),\n   * and the wallet POSTs the signature directly to our callback URL.\n   *\n   * After displaying the QR code, poll with `waitForAOPPVerification()` to\n   * detect when the user completes verification.\n   *\n   * @example\n   * ```typescript\n   * import { isAOPPChallenge } from '@portola/passage-neobank';\n   *\n   * const challenge = await passage.wallets.initiateAOPPVerification('wal_123');\n   *\n   * if (isAOPPChallenge(challenge.challenge)) {\n   *   // Display QR code with challenge.challenge.aoppUri\n   *   showQRCode(challenge.challenge.aoppUri);\n   *\n   *   // Poll for completion (user signs in their wallet app)\n   *   const result = await passage.wallets.waitForAOPPVerification(\n   *     challenge.verificationId,\n   *     { timeout: 600000 } // 10 minutes\n   *   );\n   *\n   *   if (result.status === 'VERIFIED') {\n   *     console.log('Wallet verified via AOPP!');\n   *   }\n   * }\n   * ```\n   */\n  async initiateAOPPVerification(walletId: string): Promise<VerificationChallenge> {\n    return this.execute(async () => {\n      this.debug('wallets.initiateAOPPVerification', walletId);\n\n      const response = await this.api.initiateVerification({\n        walletId,\n        initiateVerificationRequest: { method: 'AOPP' },\n      });\n\n      const data = unwrapResponse(response);\n      return {\n        verificationId: data.verificationId,\n        walletId: data.walletId,\n        method: data.method as WalletVerificationMethod,\n        status: data.status as WalletVerificationStatus,\n        challenge: data.challenge,\n        expiresAt: data.expiresAt,\n      };\n    }, 'wallets.initiateAOPPVerification');\n  }\n\n  /**\n   * Poll for AOPP verification completion\n   *\n   * Since AOPP callbacks go directly to the server (not through the frontend),\n   * this method polls the verification status until it completes, fails, or times out.\n   *\n   * @param verificationId - The verification ID from initiateAOPPVerification\n   * @param options - Polling options\n   * @param options.timeout - Max time to wait in ms (default: 600000 = 10 minutes)\n   * @param options.interval - Poll interval in ms (default: 2000 = 2 seconds)\n   * @param options.onPoll - Optional callback on each poll (for showing countdown)\n   *\n   * @example\n   * ```typescript\n   * const result = await passage.wallets.waitForAOPPVerification(verificationId, {\n   *   timeout: 600000, // 10 minutes\n   *   interval: 2000,  // Check every 2 seconds\n   *   onPoll: (verification) => {\n   *     console.log(`Status: ${verification.status}, expires: ${verification.expiresAt}`);\n   *   },\n   * });\n   * ```\n   */\n  async waitForAOPPVerification(\n    verificationId: string,\n    options: {\n      timeout?: number;\n      interval?: number;\n      onPoll?: (verification: Verification) => void;\n    } = {}\n  ): Promise<Verification> {\n    const { timeout = 600000, interval = 2000, onPoll } = options;\n    const startTime = Date.now();\n\n    return this.execute(async () => {\n      this.debug('wallets.waitForAOPPVerification', verificationId);\n\n      while (Date.now() - startTime < timeout) {\n        const verification = await this.getVerification(verificationId);\n\n        if (onPoll) {\n          onPoll(verification);\n        }\n\n        // Terminal states - return immediately\n        if (\n          verification.status === 'VERIFIED' ||\n          verification.status === 'FAILED' ||\n          verification.status === 'EXPIRED'\n        ) {\n          return verification;\n        }\n\n        // Still pending - wait and poll again\n        await new Promise((resolve) => setTimeout(resolve, interval));\n      }\n\n      // Timeout - fetch final status\n      return this.getVerification(verificationId);\n    }, 'wallets.waitForAOPPVerification');\n  }\n\n  /**\n   * Map API wallet data to Wallet type\n   */\n  private mapWallet(data: {\n    id: string;\n    address: string;\n    chain: Chain;\n    type: WalletType;\n    verified: boolean;\n    verifiedByThisNeobank: boolean;\n    verifiedAt?: string | null;\n    verificationMethod?: WalletVerificationMethod | null;\n    externalId?: string | null;\n    label?: string | null;\n    createdAt: string;\n  }): Wallet {\n    return {\n      id: data.id,\n      address: data.address,\n      chain: data.chain,\n      type: data.type,\n      verified: data.verified,\n      verifiedByThisNeobank: data.verifiedByThisNeobank,\n      verifiedAt: data.verifiedAt ?? null,\n      verificationMethod: data.verificationMethod ?? null,\n      externalId: data.externalId ?? null,\n      label: data.label ?? null,\n      createdAt: data.createdAt,\n    };\n  }\n}\n"]}